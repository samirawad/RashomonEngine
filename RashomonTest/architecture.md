# Rashomon Engine Architecture Guide

## Overview
The Rashomon Engine is a Goal-Oriented Action Planning (GOAP) proof of concept built on the **Uniform Entity Container** model and a **Behavioral Marketplace** coordination system.

---

## The Rule of Discovery
To maintain a pure container model, **Activities must never be hardcoded to an NPC.** Instead, they must be attached as **Affordances** to the entities that provide them.

---

## Activities as Scripted Scenes
Activities are **Scripted Scenes** with empty **Roles**. They are fundamental design patterns, not specific events.
1.  **Late Binding**: An activity does not know who its participants are until it is **Bound**.
2.  **Roles**: Participants are identified by keys (e.g., `Initiator`, `Target`, `Guest`). 
3.  **Instantiation**: When an NPC "discovers" an affordance, the engine creates a **fresh instance** of that activity scene.

---

## The Behavioral Marketplace (Social Coordination)
NPCs are **Social Opportunists**. They do not just follow static plans; they negotiate their participation in the world.

1.  **The Invitation (Proposal)**: When an NPC (the Initiator) plans a social activity, they send an **Invitation** to potential participants. The invitation includes the **Scene** and the **Role Payoff** (the effects that role provides).
2.  **The Evaluation**: Every tick, an NPC evaluates incoming invitations against their current highest-priority goal.
    - If the role's payoff satisfies a goal more effectively than their current plan, the NPC **Accepts**.
    - If they are busy with a higher-priority task (e.g., putting out a fire), they **Decline**.
3.  **Handshake & Commitment**: Upon acceptance, the NPC clears their current `PlanQueue` and "Subscribes" to the shared scene.
4.  **Autonomous Abandonment**: Since NPCs check their needs every tick, they can "Unsubscribe" from a scene (like a Party or a Card Game) the moment their needs change or are satisfied.
5.  **Uniformity**: This system handles everything from solo acts (walking) to complex multi-user events (parties) using the same handshake logic.

---

## Core Components
... (rest of the file)

### 1. Entities (The Universal Atom)
The base class for everything in the world. 
- **Hierarchy**: Entities contain other entities (e.g., Bob contains a Stomach and an Inventory).
- **Affordances**: Entities "offer" Activities.
- **State & Tags**: Intrinsic (Tags) and Transient (States) properties define an entity.

### 2. Agents (NPCs as Time-Sliced Containers)
Specialized entities that manage a "Personal World" and own a **Brain Update Cycle**.
- **Non-Blocking Logic**: NPCs perform exactly one "slice" of an activity per world tick.
- **Queue-Based Execution**: NPCs maintain a queue of activities generated by the planner.

### 3. Activities (Scripted Contracts)
Activities are the "verbs" of the world, designed as **Verifiable Contracts** for multi-agent coordination.
- **Targeted States**: Activities use specific, targeted keys for preconditions (e.g., `Near(Alice)` instead of a generic `NearTarget`).
- **Verification Guards**: Before applying effects, an activity MUST verify that its physical and logical conditions are still met (e.g., "Is the Target still in range?").
- **Director Logic**: Orchestrates interactions between entities over time.
- **Atomic Physical Transfer**: Securely moves entities between hierarchies (e.g., `TradeActivity` swaps items).

### 4. The Planner (Discovery-Based)
The planner recursively searches the Knowledge Graph for entities that afford the activities needed to reach a targeted goal state.

---

## Simultaneous System Flow

The simulation operates on a **Parallel Heartbeat**:

1.  **World Tick**: The Global Clock increments.
2.  **Entity Tick**: All internal entities update their states.
3.  **NPC Thought Cycle**:
    - **Perception**: NPC checks if their goal is still valid.
    - **Verification**: Current activity checks if its contract is still valid.
    - **Execution Slice**: NPC performs exactly **one tick** of the current activity.
4.  **Contract Fulfillment**: Upon completion, guards are checked. If valid, effects are applied atomically. If invalid, the activity fails without applying effects.

---

## Project Structure

```text
RashomonTest/
├── Core/               
│   ├── Entity.cs       # Base Universal Atom
│   ├── Activity.cs     # Verifiable Contract
│   ├── NPC.cs          # Time-Sliced Agent
│   └── ...             
├── Activities/         # The Script Library
└── Program.cs          # Main Parallel Loop
```
